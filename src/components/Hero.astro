---
import { ArrowDown, DollarSign } from 'lucide-astro';

// Generate random beams
const beams = Array.from({ length: 30 }, () => ({
    // Random position: aligned to 60px grid (accounting for larger screens)
    left: Math.floor(Math.random() * 50) * 60,
    // Random delay between 0 and 5s
    delay: Math.random() * 5,
    // Fall speed: 5 - 10s (slower)
    duration: 5 + Math.random() * 5
}));
---

<section class="min-h-screen flex flex-col justify-center items-center relative overflow-hidden">
  <!-- Background Abstract Elements - faint dashed grid -->
  <div class="absolute inset-0 z-0 pointer-events-none select-none">
      <svg class="absolute inset-0 w-full h-full text-zinc-900 dark:text-zinc-100 opacity-[0.15] dark:opacity-[0.2]" xmlns="http://www.w3.org/2000/svg">
          <defs>
              <pattern id="grid-pattern" width="60" height="60" patternUnits="userSpaceOnUse">
                  <path d="M 60 0 L 0 0 0 60" fill="none" stroke="currentColor" stroke-width="1" stroke-dasharray="4 6" />
              </pattern>
          </defs>
          <rect width="100%" height="100%" fill="url(#grid-pattern)" />
      </svg>

      <!-- Animated Grid Beams -->
      <div class="absolute inset-0 overflow-hidden">
          {beams.map((beam) => (
              <div 
                  class="absolute top-0 w-[1px] h-[400px] -translate-x-1/2 bg-gradient-to-b from-transparent to-zinc-900 dark:to-zinc-100 opacity-0 animate-drop"
                  style={{
                      left: `${beam.left}px`,
                      animationDelay: `${beam.delay}s`,
                      animationDuration: `${beam.duration}s`
                  }}
              />
          ))}
      </div>
      
      <!-- Radial mask to fade grid behind content - creates an oval clean spot -->
      <div class="absolute inset-0 bg-[radial-gradient(ellipse_60%_60%_at_center,_var(--tw-gradient-stops))] from-white via-white/50 to-transparent dark:from-black dark:via-black/50 dark:to-transparent"></div>

      <!-- Faint gradient overlay to fade out edges if desired, or just leave as crisp grid -->
      <div class="absolute inset-0 bg-gradient-to-b from-transparent via-transparent to-white/80 dark:to-black/80"></div>
  </div>

  <div class="container px-4 md:px-6 max-w-6xl mx-auto text-center space-y-12 z-10">
    
    <div class="space-y-6">
        <p class="text-xs md:text-sm font-mono uppercase tracking-[0.3em] text-zinc-500 dark:text-zinc-400">
            Next Generation Management
        </p>
        
        <h1 class="text-4xl sm:text-5xl md:text-7xl lg:text-8xl font-black tracking-tighter leading-snug md:leading-[1.1] selection:bg-zinc-900 selection:text-white dark:selection:bg-white dark:selection:text-black">
            The <span class="relative inline-block px-2 md:px-4 before:content-[''] before:absolute before:-inset-0.5 md:before:-inset-1 before:-skew-x-6 before:bg-black before:text-white dark:before:bg-white"><span class="relative text-white dark:text-black z-10">Operating System</span></span><br /> 
            for your 
            <span class="relative inline-block px-2 md:px-4 before:content-[''] before:absolute before:-inset-0.5 md:before:-inset-1 before:-skew-x-6 before:bg-black before:text-white dark:before:bg-white"><span class="relative text-white dark:text-black z-10">Climbing Gym</span></span>
        </h1>
    </div>

    <div class="h-16 flex items-center justify-center">
        <p class="text-xl md:text-3xl font-mono text-zinc-600 dark:text-zinc-300">
            Slate is <span id="glitch-text" class="text-black dark:text-white font-bold border-b-2 border-zinc-900 dark:border-zinc-100 pb-1">loading...</span>
        </p>
    </div>

    <div class="flex flex-col sm:flex-row gap-6 justify-center pt-8">
      <a href="#about" class="group relative min-w-[200px] px-8 py-4 bg-zinc-900 text-white dark:bg-white dark:text-black font-bold overflow-hidden transition-all hover:scale-105 active:scale-95 text-sm uppercase tracking-wider inline-flex items-center justify-center">
        <span class="relative z-10 transition-transform duration-300 group-hover:-translate-x-2">Learn More</span>
        <div class="absolute right-8 opacity-0 translate-x-4 transition-all duration-300 group-hover:opacity-100 group-hover:translate-x-0 z-10">
            <ArrowDown class="w-5 h-5" />
        </div>
        <div class="absolute inset-0 bg-white/20 translate-y-full group-hover:translate-y-0 transition-transform duration-300"></div>
      </a>
      
      <a href="#pricing" class="group relative min-w-[200px] px-8 py-4 bg-transparent border-2 border-zinc-200 dark:border-zinc-800 text-black dark:text-white font-bold transition-all hover:border-black dark:hover:border-white text-sm uppercase tracking-wider inline-flex items-center justify-center overflow-hidden">
        <span class="relative z-10 transition-transform duration-300 group-hover:-translate-x-2">Pricing</span>
        <div class="absolute right-8 opacity-0 translate-x-4 transition-all duration-300 group-hover:opacity-100 group-hover:translate-x-0 z-10">
            <DollarSign class="w-5 h-5" />
        </div>
        <div class="absolute inset-0 bg-zinc-100 dark:bg-zinc-800 translate-y-full group-hover:translate-y-0 transition-transform duration-300 -z-0"></div>
      </a>
    </div>
  </div>
</section>

<script>
    const phrases = [
        "a membership portal",
        "a user mobile app",
        "an analytics engine",
        "a point of sale",
        "a community builder",
        "your new partner"
    ];
    
    const el = document.getElementById('glitch-text');
    const chars = '!<>-_\\/[]{}â€”=+*^?#________';
    
    let counter = 0;
    
    const nextPhrase = () => {
        counter = (counter + 1) % phrases.length;
        return phrases[counter];
    };
    
    const scramble = async (element: HTMLElement, newText: string) => {
        const oldText = element.innerText;
        const length = Math.max(oldText.length, newText.length);
        const promise = new Promise<void>((resolve) => {
            let frame = 0;
            const queue: { from: string, to: string, start: number, end: number }[] = [];
            
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || '';
                const to = newText[i] || '';
                const start = Math.floor(Math.random() * 15);
                const end = start + Math.floor(Math.random() * 15);
                queue.push({ from, to, start, end });
            }
            
            const update = () => {
               let output = '';
               let complete = 0;
               
               for (let i = 0; i < length; i++) {
                   const { from, to, start, end } = queue[i];
                   let char = from;
                   
                   if (frame >= end) {
                       char = to;
                       complete++;
                   } else if (frame >= start) {
                       char = chars[Math.floor(Math.random() * chars.length)];
                   }
                   
                   output += char;
               }
               
               element.innerText = output;
               
               if (complete === length) {
                   resolve();
               } else {
                   frame++;
                   requestAnimationFrame(update);
               }
            };
            
            update();
        });
        return promise;
    };
    
    const loop = async () => {
        while(true) {
            await new Promise(r => setTimeout(r, 3000)); // Wait before changing
            if (el) {
                await scramble(el, nextPhrase());
            }
        }
    };
    
    // Start loop
    if (el) {
        el.innerText = phrases[0];
        loop();
    }
</script>

<style>
    @keyframes drop {
        0% { transform: translateY(-200px); opacity: 0; }
        10% { opacity: 1; }
        25% { transform: translateY(120vh); opacity: 0; }
        100% { transform: translateY(120vh); opacity: 0; }
    }
    .animate-drop {
        animation-name: drop;
        animation-timing-function: linear;
        animation-iteration-count: infinite;
    }
</style>
